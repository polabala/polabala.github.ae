/*
QuickAccess
White Whale Web Services
http://www.whitewhale.net/
*/
;(function($) {
  "use strict";

  var host = new RegExp(window.location.hostname);

  var defaults, internalData, methods;

  defaults = {
    links: ".qa_links a",
    result: null,
    forceSelect: true,
    onSubmit: function(e, selected) {
      if (selected.length) {
        e.preventDefault();
        var anchor = selected.eq(0).find("a");
        var href = anchor.attr("href");
        if ( anchor.attr('target') == '_blank' ) {
          var newWindow = window.open(href, '_blank');
          newWindow.opener = null;
        } else {
          window.location = href;
        }
        return;
      }
    },
    maxResults: 10,
    maxResultsPerCategory: null,
    placeholder: null,
    tooMany: "Keep typing...",
    noneFound: "Press enter to search.",
    moreResultsUrl: false,
    moreResultsMsg: false,
    recordStatisticsSearched: false,
    recordStatisticsClicked: false,
    showNoneFound: true,
    focus: false,
    removeDuplicates: false,
    mouseControls: true,
    showScore: false,
    options: {}
  };

  internalData = {
    inputField: null,
    resultTarget: null,
    categories: [],
    selectionIndex: false
  };

  methods = {
    // init
    // starts the search
    init: function(options) {
      var settings;

      options = options || {};
      settings = $.extend({}, defaults, options, internalData);

      // increase maxResults if maxResultsPerCategory is greater, this has caused confusion when users increase
      // the per cat max but then don't see that number becasue the results are limited by the max results setting
      if (settings.maxResultsPerCategory > settings.maxResults) {
        settings.maxResults = settings.maxResultsPerCategory;
      }

      return this.data("quickAccess", settings).each(function() {
        var defaultSettings, self = $(this),
            settings = self.data("quickAccess");

        // verify that this is attached to an input field
        methods.verifyInputField.apply(self);

        // verify the result target
        methods.verifyResultTarget.apply(self);

        // set categories
        methods.createCategories.apply(self);

        defaultSettings = {
          limit: settings.maxResults,
          limitPerCategory: settings.maxResultsPerCategory,
          enableTooManyResuls: false,
          remoteDataType: "json",
          minCharacters: 2,
          minWordCharacters: 2,
          alternates: true,
          groupByCategory: true,
          formatRemoteData: function(data) {

            if (settings.options.remoteDataType === 'json') { // this default format function is only for remoteDataType: html, so disable if using json
              return data;
            }
            var match, output = {};

            // wrap data in a div so that we can access all of it
            data = $("<div>" + data + "</div>");

      			if (typeof settings.links === 'string' && settings.links === 'a' && data.find('.qa_category').length) { // if a generic "a" selector is used and the data contains categories in its markup
      				var links=[];
      				$.each(data.find('.qa_category'), function(i, category) { // reset selector to an array of selectors broken down by category
      					if ($(category).attr('id') && $(category).attr('title')) {
      						links[i]={selector: '#'+$(category).attr('id')+' a', title: $(category).attr('title')};
      					};
      				});
      				if (links.length) {
      					settings.categories=links;
      				};
      			};


            // Auto-detect categories from the remote data file if they are not defined in plugin settings
            if ( !settings.categories ) {

              settings.categories = [];
              $(data).find('div').each(function(){
                var $cat = $(this);
                settings.categories.push( { 'selector': '#' + $cat.attr('id') + ' a', 'title':$cat.attr('data-label'), 'className': $cat.attr('id') } );
              });

            }

            // console.dir(settings.categories, { depth: null });

            $.each(settings.categories, function(i, category) {
              var key = "category" + i;
              if (!output.hasOwnProperty(key)) {
                output[key] = [];
              }

              $(data).find(category.selector).each(function() {
                var record = {},
                    $a = $(this),
                    keywords = '',
                    commentKeywords, dataKeywords, contentImage, dataClass, dataTopResult;

                commentKeywords = $a.html().match(/<!--([\s\w\d,\.]+)-->/i);
                if (commentKeywords && commentKeywords[1]) {
                  keywords += commentKeywords[1].replace(/,/ig, ' ') + ' ';
                }
                dataKeywords = $a.attr('data-keywords');
                if (typeof dataKeywords !== 'undefined') {
                  keywords += $.trim(dataKeywords.replace(/,/ig, ' '));
                }

                record.keywords = $.trim(keywords);
                record.link = $a.attr('href');
                record.title = $a.text();

                // Optional record properties
                record.images = null;
                record.classes = null;
                record.topresult = false;

                // Check if record is external
                record.ext = !host.test($a[0].hostname) ? true : false;

                // Image parsing would be here -JS
                contentImage = $a.find('img');
                if (contentImage.length) {
                  record.images = '';
                  contentImage.each(function(i){
                    record.images += contentImage[i].outerHTML;
                  });
                }
                // Should probably also do class parsing -JS
                dataClass = $a.attr('data-class');
                if (typeof dataClass !== 'undefined') {
                  record.classes = $.trim(dataClass.replace(/,/ig, ' '));
                }

                dataTopResult = $a.attr('data-topresult');
                if (typeof dataTopResult !== 'undefined' && dataTopResult !== 'false' && dataTopResult !== false) {
                  record.topresult = true;
                }

                output[key].push(record);
              });
            });

            return output;
          },
          onComplete: function() {
            // fires after every search
            settings.resultTarget.empty();
          },
          onResultsFound: function(results, info) {
            var queryParts = [],
                linkList = [],
                toRemove = new RegExp(/[^a-zA-Z 0-9&]+/g),
                a, b, i, category, categoryIndex, categoryTitle, result, resultLI, score,
                resultItems, currentResultList, queryRegExp;

            // prepare highlight
            for (i = 0; i < info.parsedQuery.chunks.length; i++) {
              queryParts.push(info.parsedQuery.chunks[i].replace(toRemove, ""));
            }
            for (i = 0; i < info.parsedQuery.required.length; i++) {
              queryParts.push(info.parsedQuery.required[i].replace(toRemove, ""));
            }

            // sort query parts, putting longest items first for best highlighting
            queryParts.sort(function(a, b) {
              if (a.length > b.length) {
                return -1;
              } else if (a.length < b.length) {
                return 1;
              } else {
                return 0;
              }
            });
            queryRegExp = new RegExp('(' + queryParts.join("|") + ')', 'ig');

            // remove no query tag
            settings.resultTarget.removeClass("qa_noquery");

            // loop over categories
            for (a in results) {
              var a_class = a.replace(/\s+/g, '_'); // convert space to underscore in categories

              // each category
              category = results[a];

              // only show categories that have items
              if (results.hasOwnProperty(a) && $.isArray(category) && category.length) {

                // make category element
                settings.resultTarget.append('<div class="qa_category_' + a_class + '"><ul></ul></div>');
                currentResultList = settings.resultTarget.find(".qa_category_" + a_class + " ul");
                categoryIndex = parseInt(a.replace("category", ""), 10);
                categoryTitle = (a === 'category0' && typeof options.links === 'string' && !(settings.categories[categoryIndex] && settings.categories[categoryIndex].title)) ? 'Results' : ((settings.categories[categoryIndex] && settings.categories[categoryIndex].title) ? settings.categories[categoryIndex].title : a);
                if (a) {
                  settings.resultTarget
                    .find(".qa_category_" + a_class)
                    .prepend('<div class="qa_category_title">' + categoryTitle  + '</div>');
                }

                for (b = 0; b < category.length; b++) {
                  result = category[b];
                  score = (settings.showScore) ? ' <small>' + result.score + '</small>' : '';
                  resultLI = '<li' + (result.data.classes ? ' class="' + result.data.classes + '"' : '') + '><a href="' + result.data.link + '"' + (result.data.ext ? ' rel="noopener noreferrer" target="_blank"' : '') + '>' + (result.data.images ? result.data.images + (result.data.title ? '<span class="text-wrapper">' + result.data.title.replace(queryRegExp, '<span class="qa_highlight">$1</span>') + '</span>' : '') : result.data.title.replace(queryRegExp, '<span class="qa_highlight">$1</span>')) + '</a>' + score + '</li>';
                  if (!settings.removeDuplicates || $.inArray(category[b].data.link, linkList) === -1) {
                    linkList.push(category[b].data.link);
                    if (result.data.topresult) {
                      currentResultList.prepend(resultLI);
                    } else {
                      currentResultList.append(resultLI);
                    }
                  }
                }
              }
            }

            // grab result list-items
            resultItems = settings.resultTarget.find("li");

            // load up selection
            if (settings.selectionIndex === false) {
              // nothing selected yet, should we select?
              if (settings.forceSelect) {
                settings.selectionIndex = 0;
              }
            } else if (settings.selectionIndex > resultItems.length) {
              settings.selectionIndex = (resultItems.length > 0) ? resultItems.length - 1 : 0;
            }

            // set selection
            if (settings.selectionIndex !== false) {
              resultItems.removeClass("qa_selected").eq(settings.selectionIndex).addClass("qa_selected");
            }

			// add optional more results link
			if (settings.moreResultsUrl !== false) {
				var moreResultsMsg=settings.moreResultsMsg!==false ? settings.moreResultsMsg : 'View all results&nbsp;&raquo;';
				settings.resultTarget.append('<div class="qa_more_results"><a class="qa_view_all" href="'+settings.moreResultsUrl+encodeURIComponent(settings.inputField.val())+'">'+moreResultsMsg+'</a></div>');
			}

			// record clicked search results
            if (settings.recordStatisticsClicked) {
		          resultItems.on('click', 'a', function() {
					  if (settings.inputField.val() && $(this).text() && $(this).attr('href')) {
						$.ajax({
							type: 'GET',
							async: false,
							url: settings.recordStatisticsClicked
							.replace(/{phrase}/g, encodeURIComponent(settings.inputField.val()))
							.replace(/{target_title}/g, encodeURIComponent($(this).text()))
							.replace(/{target_url}/g, encodeURIComponent($(this).attr('href')))
						});
					  };
		          });
            }

          },
          onNoResultsFound: function() {
            if(!settings.showNoneFound) {
              settings.resultTarget.addClass("qa_noquery");
  			  // add optional more results link
  			  if (settings.moreResultsUrl !== false) {
  				  var moreResultsMsg=settings.moreResultsMsg!==false ? settings.moreResultsMsg : 'View all results&nbsp;&raquo;';
  				  settings.resultTarget.append('<div class="qa_more_results"><a class="qa_view_all" href="'+settings.moreResultsUrl+encodeURIComponent(settings.inputField.val())+'">'+moreResultsMsg+'</a></div>');
  			  }
              return;
            }
            settings.resultTarget.removeClass("qa_noquery").append('<div class="qa_message qa_nonefound">' + settings.noneFound + '</div>');
			// add optional more results link
			if (settings.moreResultsUrl !== false) {
				var moreResultsMsg=settings.moreResultsMsg!==false ? settings.moreResultsMsg : 'View all results&nbsp;&raquo;';
				settings.resultTarget.append('<div class="qa_more_results"><a class="qa_view_all" href="'+settings.moreResultsUrl+encodeURIComponent(settings.inputField.val())+'">'+moreResultsMsg+'</a></div>');
			}
          },
          onNotEnoughCharacters: function() {
            settings.resultTarget.removeClass("qa_noquery").append('<div class="qa_message qa_toomany">' + settings.tooMany + '</div>');
          },
          onNoQuery: function() {
            settings.resultTarget.addClass("qa_noquery");
          }
          };

          // start up QuickSearch
          if (settings.combOptions) { // BC for jQuery comb
            settings.options=settings.combOptions;
          }
          settings.inputField
            .QuickSearch($.extend({}, defaultSettings, settings.options))
            .focus(function() {
              var $this = $(this),
                  search_data = $this.QuickSearch('getData');

              settings.resultTarget.removeClass("qa_blur");
              if (search_data.loadFrom && !search_data.dataPrepared && !search_data.forceReloadOnEachKeypress) {
                $this.QuickSearch('search', '');
              }
            })
            .blur(function() {
              setTimeout(function() {
                settings.resultTarget.addClass("qa_blur");
              }, 200);
            })
            .keydown(function(e) {
              var selected, index;

              // handle keyboard navigation
              switch(e.keyCode) {
                case 38:  // up-arrow
                  e.preventDefault();
                  selected = settings.resultTarget.find(".qa_selected");
                  index = settings.resultTarget.find("li").index(selected);
                  selected.removeClass("qa_selected");

                  if (index > -1) {
                    // something is selected
                    if (index > 0) {
                      settings.selectionIndex = index - 1;
                    } else if (settings.forceSelect) {
                      settings.selectionIndex = settings.resultTarget.find("li").length - 1;
                    } else {
                      settings.selectionIndex = false;
                    }
                  } else {
                    // nothing is selected, select the last item
                    settings.selectionIndex = settings.resultTarget.find("li").length - 1;
                  }

                  if (settings.selectionIndex !== false) {
                    settings.resultTarget.find("li").eq(settings.selectionIndex).addClass("qa_selected");
                  }
                  break;
                case 40:  // down-arrow
                  e.preventDefault();
                  selected = settings.resultTarget.find(".qa_selected");
                  index = settings.resultTarget.find("li").index(selected);
                  selected.removeClass("qa_selected");

                  if (index > -1) {
                    // something is selected
                    if (index < settings.resultTarget.find("li").length - 1) {
                      settings.selectionIndex = index + 1;
                    } else if (settings.forceSelect) {
                      settings.selectionIndex = 0;
                    } else {
                      settings.selectionIndex = false;
                    }
                  } else {
                    // nothing is selected, select the last item
                    settings.selectionIndex = 0;
                  }

                  if (settings.selectionIndex !== false) {
                    settings.resultTarget.find("li").eq(settings.selectionIndex).addClass("qa_selected");
                  }
                  break;
                case 13:  // enter/return
                  settings.onSubmit.apply(self, [e, settings.resultTarget.find("li.qa_selected")]);
                  break;
              }
            });

          if (settings.mouseControls) {
            settings.resultTarget
              .addClass("qa_mouse")
              .delegate("li", "mouseenter", function() {
                settings.selectionIndex = settings.resultTarget.find("li").index($(this));
                settings.resultTarget
                  .find("li")
                  .removeClass("qa_selected")
                    .eq(settings.selectionIndex)
                    .addClass("qa_selected");
              });
          }


          // handle focus option
          if (settings.focus) {
            settings.inputField.focus();
          }

          // handle placeholder option
          if (settings.placeholder) {
            settings.inputField.attr("placeholder", settings.placeholder);
          }

          // run in case field is pre-populated
          if (settings.inputField.val()) {
            settings.inputField.keyup();
          }

          // collect submitted search results
          if (settings.recordStatisticsSearched) {
	          settings.inputField.closest('form').submit(function() {
				  if (settings.inputField.val()) {
					$.ajax({
						type: 'GET',
						async: false,
						url: settings.recordStatisticsSearched.replace(/{phrase}/g, encodeURIComponent(settings.inputField.val()))
					});
				  };
	          });
          }

        });
    },


    // verifyInputField
    // verify that the attachment is on an input field, if not, make one
    verifyInputField: function() {
      var self = $(this),
          settings = self.data("quickAccess");

      if (self.is("input[type=text], textarea")) {
        settings.inputField = self;
      } else {
        settings.inputField = $('<input type="text" class="qa_search_query" />').prependTo(self);
      }
    },


    // verifyResultTarget
    // verify that a target is specified for results, if not, make one
    verifyResultTarget: function() {
      var self = $(this),
          settings = self.data("quickAccess");

      if (settings.results) {
        settings.resultTarget = $(settings.results).eq(0);
      } else {
        settings.resultTarget = $('<div class="qa_results"></div>').insertAfter((settings.inputField.next() && (settings.inputField.next().attr('type')==='submit' || settings.inputField.next().attr('type')==='button')) ? settings.inputField.next() : settings.inputField);
      }

      settings.resultTarget
        .addClass("qa_blur")
        .addClass("qa_noquery");
    },


    // createCategories
    // creates a list of categories based on the selectors entered
    createCategories: function() {
      var self = $(this),
          settings = self.data("quickAccess");

      if ( settings.links === "auto" ) {
        settings.categories = false;
      }
      else if (typeof settings.links === "string") {
        settings.categories = [ { selector: settings.links } ];
      }
      else {
        settings.categories = settings.links;
      }
    }
  };


  // start the plugin
  $.fn.quickAccess = function(method) {
    if (methods[method]) {
      return methods[method].apply(this, Array.prototype.slice.call(arguments, 1));
    } else if (typeof method === "object" || $.isFunction(method) || !method) {
      return methods.init.apply(this, arguments);
    } else {
      $.error("Method " + method + " does not exist for jQuery.quickAccess.");
    }
  };
})(jQuery);


/*
 * jQuery QuickSearch - v1.0
 * A simple (yet highly-customizable) search layer that helps users find
 * needles in data haystacks based on relevancy.
*/
;(function($) {
  "use strict";

  var defaults, internalData, methods;

  defaults = {
    // matching & scoring
    matchWeights: {
      partialWord: 1,
      partialFirstWord: 2,
      partialWordStart: 1,
      partialFirstWordStart: 2,
      wholeWord: 5,
      wholeFirstWord: 5,
      partialWhole: 2,
      partialWholeStart: 2,
      whole: 10
    },
    minCharacters: 3,
    minWordCharacters: 2,
    scoreThreshold: 1,
    propertyWeights: {},

    // input
    queryMode: "boolean",
    stemming: false,
    customStemming: null,
    alternates: false,
    customAlternates: null,
    includeFullQuery: true,
    preformat: function(keyword) {
      return keyword.replace(/[^\w\d\-\+\s&�'�\*]/ig, "");
    },

    // output
    limit: false,
    enableTooManyResults: false,
    delay: 200,
    sortByScore: true,
    groupByCategory: false,
    onNoQuery: function() {},
    onNotEnoughCharacters: function() {},
    onNoResultsFound: function() {},
    onError: function() {},
    onResultsFound: function(results) {},
    onComplete: function() {},
    onTooManyResultsFound: function() {},

    // data
    loadFrom: null,
    formatRemoteData: function(data) { return data; },
    forceReloadOnEachKeypress: false,
    haystack: {},
    excludeProperties: [],
    remoteDataType: "json",
    ajaxTimeout: 5000,

    // filtering
    filteredKeyCodes: [],
    filter: function() {},

    // debugging
    debug: false
  };

  internalData = {
    dataPrepared: false,
    isCategorizedHaystack: false,
    queryStartTime: null,
    delayTimeout: null,
    internalHaystack: []
  };

  methods = {
    // init
    // starts the search
    init: function(options) {
      options = options || {};

      this
        .data("quicksearch", $.extend({}, defaults, options, internalData))
        .bind("keyup.quicksearch", function(e) {
          var $this    = $(this),
              settings = $this.data('quicksearch'),
              query, a;

          // trap filtered key codes
          if (settings.filteredKeyCodes.length) {
            for (a in settings.filteredKeyCodes) {
              if (settings.filteredKeyCodes[a] === e.keyCode) {
                settings.filter.apply($this, [e.keyCode]);
                return this;
              }
            }
          }

          try {
            // test keystroke
            methods.testRelevantKeystroke.apply($this, [e.keyCode]);

            // empty results box until
            settings.onComplete.apply(this);

            // preformat
            query = settings.preformat.apply($this, [$.trim( $this.val() )]);

            // test for a valid query
            methods.testValidQuery.apply($this, [query]);

            $this.data('query', query); // store current query on input element

            // short-circuit if minimum characters isn't reached
            if (query.length < settings.minCharacters) {
              throw("");
            }

            // enforce delay if set
            if (settings.delay) {
              clearTimeout(settings.delayTimeout);
              settings.delayTimeout = setTimeout(function() {
                methods.search.apply($this, [query, settings.forceReloadOnEachKeypress]);
              }, settings.delay);
            } else {
              if (settings.forceReloadOnEachKeypress && settings.loadFrom && settings.debug) {
                console.log("Set the 'delay' setting for better performance.");
              }
              methods.search.apply($this, [query, settings.forceReloadOnEachKeypress]);
            }
          } catch (error) {
            if (settings.debug) {
              console.debug(error);
            }
          }
        });

      return this.each(function() {});
    },


    // lookUp
    // takes a given query and performs search
    lookUp: function(query) {
      var $this = $(this),
          settings = $this.data("quicksearch"),
          params, data;

      if (!query) return;

      // for debugging purposes, measures search length
      settings.queryStartTime = $.now();

      // parse out search parameters
      params = methods.parseSearchParameters.apply($this, [query]);

      // trim haystack to fit query
      data = methods.removeDisallowedMatches.apply($this, [params, settings.internalHaystack]);

      methods.searchOverData.apply($this, [params, data, query]);
    },

    // search
    // loads data either locally or from remote source
    search: function(query, forceReload) {
      var $this = $(this),
          settings = $this.data("quicksearch"),
          loadFromURL;

      // we've already loaded data
      if (settings.dataPrepared && !forceReload) {
        methods.lookUp.apply($this, [query]);
        return;
      }

      // on our way to preparing data, flag instance as such
      settings.dataPrepared = true;

      // load via ajax if necessary
      if (settings.loadFrom) {
        methods.loadRemoteData.apply($this, [query]);

      } else {
        methods.setHaystack.apply($this, [ $('body').html() ]);
        methods.lookUp.apply($this, [query]);
      }
      return this;
    },

    getData: function() {
      return $(this).data("quicksearch");
    },

    loadRemoteData: function(query) {
        // settings.loadFrom can be a function, allowing for dynamic ajax URLs
        var $this       = $(this),
            settings    = $this.data("quicksearch"),
            loadFromURL = ($.isFunction(settings.loadFrom)) ? settings.loadFrom.apply($this) : settings.loadFrom;

        $.ajax({
          url: loadFromURL,
          dataType: settings.remoteDataType,
          timeout: settings.ajaxTimeout,
          error: function(jqXHR, status, error) {
            throw("Ajax error: " + error);
          },
          success: function(data, status, jqXHR) {
            methods.setHaystack.apply($this, [data]);
            methods.lookUp.apply($this, [query]);
          }
        });
    },

    // prepareData
    // parses and prepared data to be used
    setHaystack: function(data, callback) {
      var $this = $(this),
          settings = $this.data("quicksearch"),
          output = [],
          a, b, record;

		  callback = callback || $.noop;
      data = settings.formatRemoteData.apply($this, [data]);

      // find non-categorized data
      if ($.isArray(data)) {
        for (a = 0; a < data.length; a++) {
          record = data[a];
          record._category = "data";
          output.push(record);
        }

      // find categorized data
      } else {
        $this.data("quicksearch").isCategorizedHaystack = true;
        for (a in data) {
          if (data.hasOwnProperty(a)) {
            if (!$.isArray(data[a])) {
              continue;
            }

            for (b = 0; b < data[a].length; b++) {
              record = data[a][b];
              record._category = a;
              output.push(record);
            }
          }
        }
      }

      // remove any disallowed properties in the settings
      output = methods.removeDisallowedProperties.apply($this, [output]);

      // set the prepared data to this instance's haystack
      settings.internalHaystack = output;

      // call callback
      callback.apply($this);
    },

    // searchOverData
    // look through each result attempting to find good matches
    searchOverData: function(params, data, rawQuery) {
      var $this = $(this),
          settings = this.data("quicksearch"),
          output = [],
          info = {},
          outputLength = 0,
          obj, found, regex, property, words, strength, result, score,
          categorizedOutput, cleaned, matchWeight, clonedData,
          a, b, c, d, e, f, g, h, i, j;  // iterators

      // make sure there's data to search over
      if (!data.length) {
        // the haystack is empty because it was parsed by a boolean
        // search return that no results were found
        if (params.required) {
          settings.onComplete.apply(this);
          settings.onNoResultsFound.apply(this, [info]);
          settings.onError.apply(this);
          if (settings.debug) {
            throw("No results found.");
          }

        // otherwise, the haystack is empty and that's an error
        } else {
          settings.onComplete.apply($this);
          settings.onError.apply($this);
          if (settings.debug) {
            throw("Empty haystack.");
          }
        }
        return;
      }

      // set up informational object to be returned alongside data object
      info = {
        totalResults: 0,
        rawQuery: rawQuery,
        parsedQuery: params,
        queryTime: 0.0
      };

      // loop over records
      for (a in data) {
        if (data.hasOwnProperty(a)) {
          obj = data[a].pruned;

          // counters
          found = {
            partialWord: 0,
            partialFirstWord: 0,
            partialWordStart: 0,
            partialFirstWordStart: 0,
            wholeWord: 0,
            wholeFirstWord: 0,
            partialWhole: 0,
            partialWholeStart: 0,
            whole: 0
          };

          // loop over each query chunk
          for (b = 0; b < params.chunks.length; b++) {
            regex = {
              whole: new RegExp("^" + params.chunks[b] + "$", "ig"),
              partial: new RegExp(params.chunks[b], "ig"),
              partialFromStart: new RegExp("^" + params.chunks[b], "ig")
            };

            // loop over each data property
            for (c in obj) {
              if (obj.hasOwnProperty(c)) {
                property = ($.isArray(obj[c])) ? obj[c].join(" ") : obj[c];

                if (typeof property !== "string") {
                  continue;
                }

                words = property.split(/\s+/ig);
                strength = settings.propertyWeights[c] || 1;

                // reset iterator
                i = 0;

                // whole matching
                result = property.match(regex.whole);
                if (result) {
                  found.whole += result.length;
                }

                result = property.match(regex.partial);
                if (result) {
                  found.partialWhole += result.length;
                }

                result = property.match(regex.partialFromStart);
                if (result) {
                  found.partialWholeStart += result.length;
                }

                // word matching
                for (d = 0; d < words.length; d++) {
                  result = words[d].match(regex.whole);
                  if (result) {
                    found.wholeWord += strength * result.length;

                    if (i === 0) {
                      found.wholeFirstWord += strength * result.length;
                    }
                  }

                  result = words[d].match(regex.partial);
                  if (result) {
                    found.partialWord += strength * result.length;

                    if (i === 0) {
                      found.partialFirstWord += strength * result.length;
                    }
                  }

                  result = words[d].match(regex.partialFromStart);
                  if (result) {
                    found.partialWordStart += strength * result.length;

                    if (i === 0) {
                      found.partialFirstWordStart += strength * result.length;
                    }
                  }

                  i++;
                }
              }
            }
          }

          // calculate score
          score = 0;

          // loop through match weights, taking user-set options if we can
          for (e in defaults.matchWeights) {
            if (defaults.matchWeights.hasOwnProperty(e)) {
              matchWeight = (typeof settings.matchWeights[e] !== "undefined") ? settings.matchWeights[e] : defaults.matchWeights[e];
              score += found[e] * matchWeight;
            }
          }

          data[a].score = score;
        }
      }

      // create a clone of data to not re-arrange master list
      clonedData = methods.cloneArray.apply(null, [data]);

      // perform sorting if needed
      if (settings.sortByScore) {
        clonedData.sort(function(a, b) {
          if (a.score > b.score) {
            return -1;
          } else if (a.score < b.score) {
            return 1;
          } else {
            return 0;
          }
        });
      }

      // only records whose score meets the threshold
      for (f in clonedData) {
        if (clonedData[f].score >= settings.scoreThreshold) {
          cleaned = $.extend({}, clonedData[f]);

          // remove our working object
          delete cleaned.pruned;

          output.push(cleaned);
        }
      }

      // add total results to info array
      info.totalResults = output.length;

      // if group by category, rearrange - will handle limiting
      if (settings.groupByCategory && settings.isCategorizedHaystack) {
        output = methods.categorizeOutput.apply(this, [output]);
        $.each(output, function(i, cat) { outputLength += cat.length; });
      // or trim outputs to limit if it was set
      } else if (settings.limit) {
        // if we do not want more results than the limit
        if (settings.enableTooManyResults && output.length > settings.limit) {
          settings.onComplete.apply(this);
          settings.onTooManyResultsFound.apply(this, [info]);
          settings.onError.apply(this);
          if (settings.debug) {
            throw("Too many results found.");
          }
          return;
        }

        output = output.slice(0, settings.limit);
        outputLength = output.length;
      // otherwise, the size is the size
      } else {
        outputLength = output.length;
      }

      // add query time to info array
      info.queryTime = methods.markEndQueryTime.apply(this);

      // if nothing was found
      if (outputLength === 0) {
        settings.onComplete.apply(this);
        settings.onNoResultsFound.apply(this, [info]);
        settings.onError.apply(this);
        if (settings.debug) {
          throw("No results found.");
        }
        return;
      }

      // results found
      settings.onComplete.apply(this);
      settings.onResultsFound.apply(this, [output, info]);
    },

    // Converts output to an object with an array of results for each category
    categorizeOutput: function(output) {
      var settings = $(this).data("quicksearch"),
          categorized_output = {},
          count = {},
          limit, category, g;

        // enforce limit set for all items regardless of category
        limit = (settings.limit && settings.limit < output.length) ? settings.limit : output.length;

        for (g = 0; g < limit; g++) {
          category = output[g].category;

          if (!categorized_output[category]) {
            categorized_output[category] = [];
          }

          if (category in count) {
            count[category]++;
          } else {
            count[category] = 0;
          }

          // enforce per category limit
          if (!settings.limitPerCategory || count[category] < settings.limitPerCategory) {
            categorized_output[category].push(output[g]);
          }
        }
        return categorized_output;
    },

    // removeDisallowedProperties
    // removes data properties that are on the exclusion list
    removeDisallowedProperties: function(data) {
      var a, b,
          output = [],
          settings = this.data("quicksearch");

      for (a = 0; a < data.length; a++) {
        var localData,
            category = data[a]._category;

        delete data[a]._category;
        localData = $.extend(true, {}, data[a]);

        for (b = 0; b < settings.excludeProperties.length; b++) {
          delete localData[settings.excludeProperties[b]];
        }

        output.push({
          data: $.extend(true, {}, data[a]),
          pruned: localData,
          score: 0,
          category: category
        });
      }

      return output;
    },


    // removeDisallowedMatches
    // removes matches that have been disallowed by a boolean search
    removeDisallowedMatches: function(params, data) {
      var a, b, record,
          settings = this.data("quicksearch"),
          newData = [],
          disallowed = new RegExp(params.disallowed.join("|"), "i"),
          required = new RegExp("(?=.*" + params.required.join(")(?=.*") + ")", "i");

      // this only applies to boolean mode
      if (settings.queryMode !== "boolean" || (params.disallowed.length === 0 && params.required.length === 0)) {
        return data;
      }

      // loop through all data
      for (a = 0; a < data.length; a++) {
        try {
          record = "";

          // loop through each property
          for (b in data[a].pruned) {
            if (data[a].pruned.hasOwnProperty(b)) {
              // string these together
              record += " " + data[a].pruned[b];
            }
          }

          if (params.disallowed.length && disallowed.test(record) === true) {
            // a disallowed was found, we don't want this
            throw("");
          }

          if (params.required.length && !required.test(record)) {
            // a required was missing, we don't want this
            throw("");
          }
        } catch (err) {
          continue;
        }

        newData.push(data[a]);
      }

      return newData;
    },


    // standardizeArray
    // removes duplicate values in a given array
    standardizeArray: function(array) {
      var a,
          i = 0,
          output = [],
          sorted = array.sort();

      for (a = 0; a < sorted.length; a++) {
        if (typeof sorted[a] !== "string") {
          continue;
        }

        sorted[a] = sorted[a].toLowerCase();
      }

      for (i; i <= sorted.length - 1; i++) {
        if (sorted[i + 1] !== sorted[i]) {
          output.push(sorted[i]);
        }
      }

      return output;
    },


    // cloneArray
    // clones a given array to not alter the original
    cloneArray: function(array) {
      var i = 0,
          newArray = [],
          arrayLength = array.length;

      for (i; i < arrayLength; i++) {
        newArray.push($.extend(true, {}, array[i]));
      }

      return newArray;
    },



    // validation tests
    // -----------------------------------------------------------------------

    // testRelevantKeystroke
    // validates that the keystroke alters the query
    testRelevantKeystroke: function(keyCode) {
      switch (keyCode) {
        case 13:  // enter/return
        case 16:  // shift
        case 17:  // control
        case 18:  // alt/option
        case 91:  // command
        case 20:  // caps lock
        case 9:   // tab
        case 37:  // left-arrow
        case 38:  // up-arrow
        case 39:  // right-arrow
        case 40:  // down-arrow
        case 27:  // escape
          throw("");

        default:
          // console.log("KeyCode " + keyCode + " accepted.");
      }
    },


    // testValidQuery
    // validates that the query exists and is long enough
    testValidQuery: function(query) {
      var settings = this.data("quicksearch");

      // no query
      if (query.length === 0) {
        settings.onComplete.apply(this);
        settings.onNoQuery.apply(this);
        settings.onError.apply(this);
        if (settings.debug) {
          throw("No query.");
        }

      // not enough characters have been typed
      } else if (query.length < this.data("quicksearch").minCharacters) {
        settings.onComplete.apply(this);
        settings.onNotEnoughCharacters.apply(this);
        settings.onError.apply(this);
        if (settings.debug) {
          throw("Not enough characters.");
        }
      }
    },



    // helpers
    // -----------------------------------------------------------------------

    // parseSearchParameters
    // parses out search parameters based on search mode
    parseSearchParameters: function(query) {
      var words, word, stemmed, alternate, parts, x,
          self = $(this),
          settings = self.data("quicksearch");

      // "words" - search each word individually
      if (settings.queryMode === "words") {
        parts = {
          chunks: [],
          required: [],
          disallowed: []
        };

        if (settings.stemming) {
          words = query.split(/\s+/ig);
          for (x = 0; x < words.length; x++) {
            word = words[x].toLowerCase();
            stemmed = methods.stemWord.apply(self, [word]);
            alternate = methods.getAlternateWords.apply(self, [word]);

            if (stemmed) {
              parts.chunks.push(stemmed);
            }

            if (alternate) {
              parts.chunks = $.merge(parts.chunks, alternate);
            }

            parts.chunks.push(word);
          }
        } else {
          parts.chunks = query.split(/\s+/ig);
        }

        if (settings.includeFullQuery) {
          parts.chunks.push(query);
        }

      // "boolean" - require words, disallow words
      } else if (settings.queryMode === "boolean") {
        words = query.split(/\s+/ig);

        parts = {
          chunks: [],
          required: [],
          disallowed: []
        };

        for (x = 0; x < words.length; x++) {
          word = words[x].toLowerCase();
          stemmed = methods.stemWord.apply(self, [word]);
          alternate = methods.getAlternateWords.apply(self, [word]);

          if (word.indexOf("-") === 0 && word.length >= settings.minWordCharacters + 1) {
            parts.disallowed.push(word.substring(1));
          } else if (word.indexOf("+") === 0 && word.length >= settings.minWordCharacters + 1) {
            parts.required.push(word.substring(1));
          } else if (word.length >= settings.minWordCharacters) {
            if (stemmed) {
              parts.chunks.push(stemmed);
            }

            if (alternate) {
              parts.chunks = $.merge(parts.chunks, alternate);
            }
            parts.chunks.push(word);
          }
        }

        if (parts.required.length > 0 && parts.chunks.length === 0) {
          parts.chunks = parts.required;
        }

        if (settings.includeFullQuery) {
          parts.chunks.push(query);
        }

      // default - search entire phrase at once
      } else {
        words = query.toLowerCase();
        stemmed = methods.stemWord.apply(self, [words]);
        alternate = methods.getAlternateWords.apply(self, [words]);

        if (stemmed) {
          words.push(stemmed);
        }

        if (alternate) {
          parts.chunks = $.merge(parts.chunks, alternate);
        }

        parts = {
          chunks: [words],
          required: [],
          disallowed: []
        };
      }

      // standardize arrays
      parts = {
        chunks: methods.standardizeArray.apply(self, [parts.chunks]),
        required: methods.standardizeArray.apply(self, [parts.required]),
        disallowed: methods.standardizeArray.apply(self, [parts.disallowed])
      };

      return parts;
    },


    // stemWord
    // attempts to stem the given word, returns word or false if unstemmable
    stemWord: function(word) {
      var self = $(this),
          settings = self.data("quicksearch");

      if (!settings.stemming) {
        return false;
      }

      // use custom stemming function instead
      if ($.isFunction(settings.customStemming)) {
        return settings.customStemming.apply(self, [word]);
      }

      // check for plural
      if (word.length >= 4 && word.substring(word.length - 1) === "s" && word.substring(word.length - 2) !== "ss") {
        return word.substring(0, word.length -1);
      }

      return false;
    },


    // getAlternateWords
    // attempts to find an alternate word, returns array of alternates or false if none
    getAlternateWords: function(word) {
      var matches = [],
          self = $(this),
          settings = self.data("quicksearch");

      if (!settings.alternates) {
        return false;
      }

      // use custom stemming function instead
      if ($.isFunction(settings.customAlternates)) {
        return settings.customAlternates.apply(self, [word]);
      }

      // check for alternates
      switch (word) {
        case "and":
          return [ "&" ];

        case "&":
          return [ "and" ];
      }

      // check for regex match alternates
      if (word.indexOf("�") !== -1) {
        matches.push(word.replace(/�/g, "'"));
        matches.push(word.replace(/�/g, "�"));
      } else if (word.indexOf("'") !== -1) {
        matches.push(word.replace(/'/g, "�"));
        matches.push(word.replace(/'/g, "�"));
      } else if (word.indexOf("�") !== -1) {
        matches.push(word.replace(/�/g, "'"));
        matches.push(word.replace(/�/g, "�"));
      }

      if (matches.length) {
        return matches;
      }

      return false;
    },


    // markEndQueryTime
    // adds the time to query to the console (if debug is on)
    markEndQueryTime: function() {
      var time,
          self = $(this),
          settings = self.data("quicksearch");

      time = (($.now() - settings.queryStartTime) / 1000).toFixed(3) + "s";

      if (settings.debug) {
        console.debug("Query time: " + time);
      }

      return time;
    }
  };


  // start the plugin
  $.fn.QuickSearch = function(method) {
    if (methods[method]) {
      return methods[method].apply(this, Array.prototype.slice.call(arguments, 1));
    } else if (typeof method === "object" || $.isFunction(method) || !method) {
      return methods.init.apply(this, arguments);
    } else {
      $.error("Method " + method + " does not exist for jQuery.QuickSearch.");
    }
  };
})(jQuery);